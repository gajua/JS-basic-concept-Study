# 1. var의 특징과 호이스팅

```
console.log(a) // undefined  -> 왜 레퍼런스에러가 아닌 언디파인드가 나올까?
 var a = 1; 
 var b = 2;
console.log(b) // 2
```
그 이유는 위의 코드는 아래의 순서대로 진행이된다. 밑을 참고하자


변수의 생성과정은 크게
> 1) 선언 단계 -변수 선언 단계에서는 값을 저장하기 위한 메모리 공간을 확보한다. 그리고 저장한 메모리를 식별하기 위한 변수 이름을 설정하는 것까지 변수 선언 단계에서 진행된다.
> 2) 초기화 단계 -변수 선언 단계를 거쳐 메모리 공간을 확보한 후에는 해당하는 메모리 공간에 undefined를 할당하여 초기화한다.
> 3) 할당 단계 - 초기화 단계까지 마쳐 undefined가 할당된 변수에 원하는 값을 재할당한다.

이렇게 세 단계로 나뉘는데 var의 경우는 선언과 초기화가 동시에 이루어 진다.

다시 맨 위에서 예시로 든 코드는 아래처럼 실행이 된다.


 **1) 선언,초기화**
```
var a;
var b;
```


 ---> 런타임 이전에 선언이 된다.(이것이 호이스팅) 그래서 var는 변수 할당 전에 console.log를 찍으면 선언만 되었고 값이 할당이 안되었기 때문에 undefined가 찍힌다.

**2) 할당**
```
a = 1;
b = 2;
```



이런식으로 변수의 선언이 런타임 이전에!(코드의 순서가 어떤것이든 가장먼저!) 실행이된다.
이처럼 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트의 고유의 특징이 "변수 호이스팅" 이라고 한다!

사실 변수 선언뿐 아니라 모든 식별자(변수, 함수, 클래스 등)는 호이스팅이 된다. 모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문이다.

추가로
let과 const는 선언과 초기화가 따로 진행이되기 떄문에
선언하기 전에 콘솔을 찍으면 이렇게 에러가 나옵니다
![image](https://user-images.githubusercontent.com/101968934/200105265-a774738a-c362-4f2f-a627-cdf32f35cda7.png)



# 2. var, let, const의 스코프레벨

var는 함수레벨 스코프 -> 함수밖으로 못나간다! 
let, const는 블록레벨 스코프 -> 블록(for, if, while... 등등) 밖으로 못나간다!

변수의 값을 찾는건 블록 스코프(안쪽 local)에서 찾고, 점점 밖으로(global)로 찾아 나간다! 이것이 "스코프 체이닝"

**그래서 var를 쓰지말아야 하는 이유는!**
--> 함수레벨 스코프는 전역변수를 남발할 가능성을 높인다. 이로인해 의도치 않게 전역 변수가 중복 선언되는 경우가 발생하기 때문!



# 3. 렉시컬 스코프

렉시컬 스코프는 함수를 어디서 호출하는지가 아니라 어디에 선언하였는지에 따라 결정된다.
```
let x = "a"
    const a = function(){
        let x = '난 a'
        b()
    }
const b = function(){
        console.log(x)
    }
a()
//a
```
이처럼 a를 실행하는데 있어 함수 b는 a안에서 호출하였지만 a 밑에서 선언하였기에! (선언한 위치가 중요하다!) a()를 실행하면 x 의 값이 'a'가 나온다!
